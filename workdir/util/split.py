#!/usr/bin/env python3
# This script performs hierarchical clustering to a numpy matrix
# Argument specifications:
#   argv[1] The numpy matrix file
#   argv[2] Labels for the dimensions (generated by sourmash)
#   argv[3] Regex for matching the labels, eg. (?<=raw/).+(?=_1\.fastq)
#   argv[4] Output base name
import re
import json
import numpy as np
import pandas as pd
from os import path
from sys import argv, stderr
import scipy.spatial.distance as sdist
from scipy.cluster.hierarchy import linkage, fcluster

mat_file = argv[1]
cellname_regex = re.compile(argv[3])
labels = [ x[0] for x in pd.read_csv(argv[2], header = None, delimiter = '\t', dtype = { 0: object }).values.tolist() ]
cellnames = [ cellname_regex.findall(path)[0] for path in labels ]
output_basename = argv[4]

# The default output of sourmash is a similarity matrix
# We here transform the matrix to dissimilarity distance matrix
dist_mat = 1 - np.load(mat_file)
dist_mat[np.diag_indices_from(dist_mat)] = 0
square_form = sdist.squareform(dist_mat)

if len(cellnames) != dist_mat.shape[0]:
    print('Incompatible labels and distance matrix.', file = stderr)

# Perform hierarchical clustering and split the dendrogram
# using complete linkage method and distance criterion
# to bound the distances within clusters. 
assignments = fcluster(linkage(square_form, method = 'complete'), 0.95, criterion = 'distance')

# Write the clusters to files
gathered = [ [] for i in range(max(assignments)) ]

for i, assign in enumerate(assignments):
    gathered[assign - 1].append(cellnames[i])

for i, group in enumerate(gathered):
    with open(argv[4] + str(i + 1) + '.tsv', 'w') as outfile:
        for cellname in gathered[i]:
            outfile.write('%s\n' % cellname)
